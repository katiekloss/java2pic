Checkpoints:

    - Week 1 (Nov 15): Have symbol table and most productions finished
    - Week 2 (Nov 22): Be able to print AST
    - Week 3 (Nov 29): Three-address code generation and printing
    - Week 4 (Dec 6): Generate final ASM


General order of things to come:

- Create symbol table (linked list would be fastest...)
- Add productions that recognize variables and add to symbol table with appropriate scope
    -> Chained symbol tables (i.e. maintain stack of pointers to symbol tables, and
       copy the top table + push it when entering a new scope)
    -> symbol(symbol_name) function

- Add productions that recognize operators
    -> operator(name, op1, op2) function

- Add productions that recognize functions
    -> Start at main! Disregard everything but main! Classes don't exist!
    -> function(function_name, arglist) function

- Build overall AST

- Create code generator that accepts the AST generated by the parser
    -> ::sigh::

- Walk AST (DFS DFS DFS) and generate code along the way
    -> moar sighing


Musings:
    - We don't care about loops, conditionals, types (!?), arrays... this is basically a
      Java-flavored calculator with scoping and functions
    
    - All of the reference code is already in three-address format...

    - Generate abstract syntax tree like so:
        { $$ = node('+', $1, $3); }
